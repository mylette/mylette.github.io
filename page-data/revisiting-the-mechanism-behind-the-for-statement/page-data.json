{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/revisiting-the-mechanism-behind-the-for-statement","result":{"data":{"post":{"__typename":"MdxPost","slug":"/revisiting-the-mechanism-behind-the-for-statement","title":"Revisiting the Mechanism Behind the `for` Statement","date":"09.06.2020","tags":[{"name":"python","slug":"python"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Revisiting the Mechanism Behind the `for` Statement\",\n  \"date\": \"2020-06-09T00:00:00.000Z\",\n  \"tags\": [\"python\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Python the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement is an important tool used for specifying\\niteration. This article (literally) goes over the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement and uncovers\\nthe mechanism that makes it tick. Before disassembling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement\\nwe'll first look at the way it is used and from there slowly start diving into\\nthe internals.\"), mdx(\"h3\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"for\"), \" Statement 101\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement acts as an interface for iterating over elements\\ninside objects. The most obvious way for a C programmer to iterate\\nover an object in Python is the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> for i in range(len(planets)):\\n...     print(planets[i])\\n...\\nMercury\\nVenus\\nEarth\\nMars\\n\")), mdx(\"p\", null, \"The idea here is to create an index variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" from an arithmetic progression\\nusing the built-in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"range\"), \" function which goes from zero up to but not\\nincluding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"len(planets)\"), \". The index variable is used with the container object\\nin following way \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planets[i]\"), \" to retrieve the elements one by one in each\\niteration.\"), mdx(\"p\", null, \"The problem with the previous example is that there are several things\\nhappening at the same time making it hard to separate the \\\"business logic\\\" in\\nthe code from the boilerplate required for iterating. In order to iterate over\\nelements of a container object programmer has to build an arithmetic\\nprogression and access the element by referring to index. In a situation with\\nnested \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statements the code becomes harder to read and debug. For this\\nreason, Python provides a better way to iterate over objects.\"), mdx(\"p\", null, \"Let's rewrite the previous code block in a more Pythonic way:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> for planet in planets:\\n...    print(planet)\\n...\\nMercury\\nVenus\\nEarth\\nMars\\n\")), mdx(\"p\", null, \"Now this is much better because the \\\"business logic\\\" inside the loop is clear.\\nNotice how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop actually behaves as the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Foreach_loop\"\n  }), \"foreach\\nloop\"), \" where Python simply knows how\\nto iterate over every element inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planets\"), \" without programmer having to\\nrefer to indexes. We've introduced variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planet\"), \" which is an iteration\\nvariable and gets updated in each iteration with a new element from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \"\\nloop. This behaviour removes the noise of building an arithmetic progression\\nand referring to objects with indexes. At the same time it gives a more\\nintuitive iteration experience since the code can be read as pseudo code.\"), mdx(\"p\", null, \"In terms of performance\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://gist.github.com/vezeli/31986659ce6fa808c11bad3ebba428a7\"\n  }), \"looping_performance.py\"), \"\\nis a script that measures the execution time of the two examples and shows that\\nthe second example preforms significantly faster than iterating using indexes.\"), mdx(\"h3\", null, \"Feeding the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"for\"), \" Statement With Iterables\"), mdx(\"p\", null, \"Until now I've deliberately avoided talking about the type of objects which\\nwere passed into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement. At this point, however, I'd like to focus\\non the following question: \\\"What type of objects can we pass into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \"\\nstatement?\\\"\"), mdx(\"p\", null, \"In the previous examples, we've ignorantly passed two different types of\\nobjects into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"range\"), mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \") and assumed that\\nPython knows how to iterate over these objects. That being said, what would\\nhappen if we try to iterate over an object of type integer (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \")? Let's take\\na look at the following example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> for number in 42:\\n...    print(number)\\n...\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nTypeError: 'int' object is not iterable\\n\")), mdx(\"p\", null, \"Here we get an error message! More specifically, Python gives us a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeError\"), \"\\nsaying that it doesn't know how to iterate over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" objects because\\napparently \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" is not an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"iterable\"), \". With a bit of help from Python, in this\\nexample we came to the conclusion that in order for an object to get along with\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement it has to be iterable.\"), mdx(\"p\", null, \"An iterable is an object that knows how to return its members one at a time.\\nIterable objects are required to implement either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \"\\nmethods. These methods tell Python the order in which it should return elements\\ninside the iterable. Many of the default types such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dict\"), \"\\nand others are iterable and we don't have to worrying about implementing their\\ndunder methods, we simply pass them into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement.\"), mdx(\"p\", null, \"In order to see if an object is iterable we can call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" built-in\\nfunction and pass the object as an argument. Here's an example of passing an\\nobject of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" as an argument inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> iter(planets)\\n<tuple_iterator object at 0x7f83e198bbe0>\\n\")), mdx(\"p\", null, \"We can see that this call was successful because we didn't get any error!\\nHowever, if we try doing the same with an integer argument we get the following\\nmessage:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> iter(42)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nTypeError: 'int' object is not iterable\\n\")), mdx(\"p\", null, \"Notice that this error message is identical to the one we got when we passed an\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement!\"), mdx(\"h3\", null, \"The Mechanism Behind the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"for\"), \" Statement\"), mdx(\"p\", null, \"Python has no way of knowing how to iterate over an object passed to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \"\\nstatement and therefore it calls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" built-in function with the object\\nas an argument to get help. This is the reason we get the exact same error\\nmessage when passing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" object to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \"\\nfunction.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function searches the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \" methods inside\\nthe object to find the order in which elements should be iterated over and\\nreturns a very simple object called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"iterator\"), \" (not to be mistaken for\\niterable). The iterator is responsible for telling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement exactly\\nhow to iterate over the iterable object through a method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \". An\\niterator object can be called with Python's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function to return an\\nelement from the iterable that was used for creating the iterator. Once all the\\nelements from have been returned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function raises a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \"\\nexception. \"), mdx(\"p\", null, \"Hopefully, at this point you understand that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement is top of an\\niceberg when it comes to iteration. Under the surface there are functions like\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" that do a lot of work. Therefore, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement is\\nconsidered more of an interface for interacting with iterable objects. We can\\nrewrite the example with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planets\"), \" and expose the mechanism behind the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \"\\nstatement:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> iplanets = iter(planets)\\n>>> while True:\\n...     try:\\n...         planet = next(iplanets)\\n...     except StopIteration:\\n...         break\\n...     else:\\n...         print(planet)\\n...\\nMercury\\nVenus\\nEarth\\nMars\\n\")), mdx(\"p\", null, \"Let's go over the details one more time: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planets\"), \" is an iterable object which\\nmeans that it can be iterated over since it implements \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" or\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \" method. Calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function on an iterable object returns\\nan iterator with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" method. Afterwards, the iterator object is passed\\nto the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function inside an infinite loop and it returns elements from the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"planets\"), \" object. After the iterator returned every object it gets exhausted\\nand raises a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteraton\"), \" exception at which point Python exits the infinite\\nloop.\"), mdx(\"h4\", null, \"Adding an \", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"else\"), \" Clause\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause that follows the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement is not a well-known or used\\nfeature but it is a part of Python's flow control. The previously described\\nmechanism need to be slightly modified in order to support the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause.\\nHere's how the code looks with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> iplanets = iter(planets)\\n>>> _loop = True\\n>>> while _loop:\\n...     try:\\n...         planet = next(iplanets)\\n...     except StopIteration:\\n...         _loop = False\\n...     else:\\n...         print(planet)\\n... else:\\n...     print(f\\\"The `break` statement didn't interrupt the loop!\\\")\\n...\\nMercury\\nVenus\\nEarth\\nMars\\nThe `break` statement didn't interrupt the loop!\\n\")), mdx(\"p\", null, \"In case of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" statement Python runs the code inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause\\nonly when the logical expression in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" loop becomes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"False\"), \".\\nTherefore, we only have to changed the way of exiting the infinite loop:\\ninstead of using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement in this case the loop terminates with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_loop = False\"), \".\"), mdx(\"p\", null, \"With this implementation, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause shouldn't run when we use the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement inside the loop body. Let's add only two lines which include\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement in the loop of the code and test if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause\\nruns:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> planets = (\\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\",)\\n>>> iplanets = iter(planets)\\n>>> _loop = True\\n>>> while _loop:\\n...     try:\\n...         planet = next(iplanets)\\n...     except StopIteration:\\n...         _loop = False\\n...     else:\\n...         print(planet)\\n...         if planet == \\\"Earth\\\":\\n...             break\\n... else:\\n...     print(f\\\"The `break` statement didn't interrupt the loop!\\\")\\n...\\nMercury\\nVenus\\nEarth\\n\")), mdx(\"p\", null, \"The test uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement to exit the loop when the iteration reaches\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"Earth\\\"\"), \" object and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" clause doesn't run. Our test was a success!\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"We've seen that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement represents syntactic sugar which acts as an\\ninterface for interacting with iterable objects. Additionally, we've exposed\\nthe underlying mechanism and showed that under the surface the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement\\ncalls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" built-in functions. Hopefully, you've realized that\\nthe iterator protocol lies in the heart of Python's iteration.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"In Python 2.x the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"range\"), \" function returns an object of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"list\"), \" while\\nin Python 3.x it returns an object of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"range\"), \".\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In Python the  for  statement is an important tool used for specifying\niteration. This article (literally) goes over the  for  statement andâ€¦","timeToRead":4,"banner":null}},"pageContext":{"slug":"/revisiting-the-mechanism-behind-the-for-statement","formatString":"DD.MM.YYYY"}}}