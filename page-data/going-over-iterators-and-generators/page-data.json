{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/going-over-iterators-and-generators","result":{"data":{"post":{"__typename":"MdxPost","slug":"/going-over-iterators-and-generators","title":"Going Over Iterators and Generators","date":"05.07.2020","tags":[{"name":"python","slug":"python"},{"name":"object-oriented programming","slug":"object-oriented-programming"},{"name":"iterators","slug":"iterators"},{"name":"generators","slug":"generators"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Going Over Iterators and Generators\",\n  \"date\": \"2020-07-05T00:00:00.000Z\",\n  \"tags\": [\"python\", \"object-oriented programming\", \"iterators\", \"generators\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This article explains the grounding structure of iteration in Python. The\\narticle start by looking at the iterator protocol and implements iterator\\nobjects using object-oriented programming (OOP). Afterwards, it introduces\\ngenerator functions and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement as well as generator expressions\\nand shows how these simplify the way iterators are created. Additionally, we'll\\ntouch on some newer topics like retuning values from generators using the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement. Finally, it gives a simple primer of how to use generators\\nin OOP.\"), mdx(\"p\", null, \"All examples in this article require a version of Python > 3.3 with an\\nexception of a few examples that use the walrus operator (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":=\"), \") which is only\\navailable in Python version > 3.8.\"), mdx(\"h3\", null, \"Iterator Objects: The Iterator Protocol\"), mdx(\"p\", null, \"Because of its dynamic nature Python doesn't impose strong interfaces. However,\\nthere exist protocols and the so-called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dunder methods\"), \", methods whose names\\nstart and end with a double underscore character, that are responsible for\\nthe way objects behave.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" (and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \") dunder method is fundamental for iteration\\nbecause any object with this method is able to interact with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \"\\nbuilt-in function. Objects that have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method are also called\\niterable objects (or iterables for short). The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function calls the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method of an object and creates an iteration procedure that Python\\nfollows in order to iterate over the object.\"), mdx(\"p\", null, \"Here's a practical example, say we have a tuple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t = (0, 1, 2,)\"), \" and we'd like\\nto iterate over its elements. We'd expect that in the first iteration Python\\nfinds \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \", in the second iteration \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", and in the third iteration \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \".  After\\niterating over the last element we'd expect from Python to stop the iteration\\nprocess. This logics behind the iteration is prepared by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t.__iter__\"), \" method\\nand it's called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"iterator object\"), \" (or iterator for short).\"), mdx(\"p\", null, \"Here's the code for our previous example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> t = (0, 1, 2,)\\n>>> iterator_t = iter(t)\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function internally called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t.__iter__\"), \" dunder method and returned\\nan iterator which was assigned to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iterator_t\"), \". Once the iterator is created\\nPython knows how to iterate over the iterable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t = (0, 1, 2,)\"), \", as we'll see.\"), mdx(\"p\", null, \"Built-in types such as lists, tuples, dictionaries, sets and others, are\\niterable objects and have both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \" dunder methods.\\nTherefore, there's no need to implement these dunder methods for the built-in\\ntypes because Python already knows how to do this. On the other hand, for\\nuser-defined types (classes) it's important to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" methods\\nwhich return iterators in order to iterate over them (or use them in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \"\\nloop).\"), mdx(\"p\", null, \"Next we'll learn about the structure of iterators and how to write them using\\nOOP.\"), mdx(\"h4\", null, \"The Iterator Protocol\"), mdx(\"p\", null, \"In order for any object to be an iterator it has to supports the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/stdtypes.html#typeiter\"\n  }), \"iterator\\nprotocol\"), \". There are\\nthree rules which every iterator must satisfy: it must keep a state which tells\\nwhat is the current item in iteration process; it has to modify the state\\ninside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" dunder method with next element in iteration process and\\nreturn it or raise the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception in case there are no more\\nelements; it must have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method which returns the same iterator.\"), mdx(\"p\", null, \"It's easy to show that tuple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t = (0, 1, 2,)\"), \" doesn't respect the third rule of\\nthe iterator protocol where as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iterator_t\"), \" does:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> t = (0, 1, 2,)\\n>>> t is (iterator_t := iter(t))\\nFalse\\n>>> iterator_t is iter(iterator_t)\\nTrue\\n\")), mdx(\"p\", null, \"Because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" built-in function simply calls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t.__iter__\"), \" method, the\\nprevious code block is semantically equivalent to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> t = (0, 1, 2,)\\n>>> t is (iterator_t := t.__iter__())\\nFalse\\n>>> iterator_t is iterator_t.__iter__()\\nTrue\\n\")), mdx(\"p\", null, \"Additionally, we can show that our tuple doesn't have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" method while\\nits iterator does:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> hasattr(t, \\\"__next__\\\")\\nFalse\\n>>> hasattr(iterator_t, \\\"__next__\\\")\\nTrue\\n\")), mdx(\"p\", null, \"The same way the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \"  function calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" dunder method, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \"\\nbuilt-in function calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" dunder method. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" method does all of\\nthe heavy lifting because it changes the state of an iterator and returns the\\nnext element from it. Let's use it on our iterator to change its state and\\nreturn values:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> next(iterator_t)\\n0\\n>>> next(iteartor_t)\\n1\\n>>> next(iterator_t)\\n2\\n>>> next(iterator_t)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"Notice that the only way to interact with an iterator is to make it produce a\\nnew value using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. Because of their simplicity iterators are\\nvery fast and memory efficient and therefore they are used in many places in\\nPython where performance is important. Article called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mylette.rs/revisiting-the-mechanism-behind-the-for-statement\"\n  }), \"Revisiting the Mechanism\\nBehind the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"for\"), \" Statement\"), \" explains how iterators are\\nused for iteration inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop.\"), mdx(\"p\", null, \"Next, we'll implement the iterator protocol inside a class which we'll use to\\ncreate iterator objects. There, we'll show how iterators work internally.\"), mdx(\"h4\", null, \"Implementing an Iterator Object That Counts Backwards\"), mdx(\"p\", null, \"According to the iterator protocol we'll create a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \".\\nThis class will be used to instantiate iterators that count backwards from a\\nstarting number to zero in steps of one. You can think of this class as\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"iterator factory\"), \" that is used for creating new iterators.\"), mdx(\"p\", null, \"Let's define our new class and its behaviour:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"class Countdown:\\n    def __init__(self, start):\\n        self._count = start\\n\\n    def __iter__(self):\\n        return self\\n\\n    def __next__(self):\\n        if self._count > 0:\\n            self._count, count = self._count - 1, self._count\\n            return count\\n        else:\\n            raise StopIteration\\n\")), mdx(\"p\", null, \"Internal state of the class is kept inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self._count\"), \". This variable updates\\nonly when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" method is called by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. Therefore, a\\nstarting underscore in the name indicates that this is a private variable.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class has three key features:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"keeps the state inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self._count\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"modifies the state only inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \", more specifically decrements the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self._count\"), \" every time the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function is used, and raises the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self._count\"), \" becomes lower than zero to signal\\nthat iteration has ended\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"returns the same object with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method\"))), mdx(\"p\", null, \"Notice that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method of iterator objects returns the same object\\n(iterator). Therefore, iterators are iterable objects but the opposite is not\\ntrue.\"), mdx(\"p\", null, \"Let's create an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class and test it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> new_year = Countdown(3)\\n>>> new_year is iter(new_year)\\nTrue\\n>>> next(new_year)\\n3\\n>>> next(new_year)\\n2\\n>>> next(new_year)\\n1\\n>>> next(new_year)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"This test shows that instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class fulfills the iterator\\nprotocol. Namely, it keeps the state and changes it each time Python asks for a\\nnext element with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. Also calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function with\\niterator as an argument returns the same iterator.\"), mdx(\"h4\", null, \"To Infinity and Beyond: Infinite Iterators\"), mdx(\"p\", null, \"It's important that iterator raises the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception when it\\ndoesn't have more values to return. Iterators that have raised the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception are called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exhausted iterators\"), \". Previous examples\\nhave shown that iterators instantiated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class became exhausted\\nwhen their internal state (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self._count\"), \") was lower than zero. Exhausted\\niterator cannot produce values. Repopulating an exhausted iterator is the same\\nas creating a new instance.\"), mdx(\"p\", null, \"Interestingly, there exist \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"infinite iterators\"), \". These iterators don't have a\\ncondition that raises the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception. Let's write a class that\\nis used for creating infinite iterators that echoes whatever is passed to them:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"class Echo:\\n    def __init__(self, message):\\n        self._message = message\\n\\n    def __iter__(self):\\n        return self\\n\\n    def __next__(self):\\n        return self._message\\n\")), mdx(\"p\", null, \"Amazingly, the code inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Echo.__next__\"), \" method is simpler than the one in\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown.__next__\"), \" method. To create a class that instantiates infinite\\niterators it's sufficient to remove the condition for raising the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception.\"), mdx(\"p\", null, \"Let's also make sure that it works:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> troll_kid = Echo(\\\"Why?\\\")\\n>>> next(troll_kid)\\n'Why?'\\n>>> next(troll_kid)\\n'Why?'\\n>>> next(troll_kid)\\n'Why?'\\n\")), mdx(\"p\", null, \"We've used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Echo\"), \" to create an infinite iterator that represents a kid which\\nalways asks the question \\\"Why?\\\" and trolls people that way. This iterator never\\ngets exhausted because it always knows how to create a new value when the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function requests it.  Plugging this iterator inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement\\nwould really troll Python because it would go into an infinite loop trying to\\nfind a non-existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception.\"), mdx(\"p\", null, \"Python's Standard Library has a module called\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/itertools.html\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"itertools\")), \" that defines a\\nnumber of functions used for creating infinite iterators. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Echo\"), \" class\\nreimplemented a simpler version of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/itertools.html#itertools.repeat\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"itertools.repeat\")), \" function\\nthat creates an infinite iterator which repeats any object given to it.\"), mdx(\"h4\", null, \"Lazy Evaluation\"), mdx(\"p\", null, \"You've probably realized that iterator objects have two states: suspended and\\nactivated. When they're suspended they keep the internal state unchanged and as\\nsoon as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function calls them they activate and produce a value.\\nAfter the activation they suspend again. The iterator protocol allows iterators\\nto produce values only when another part of code requires that, otherwise they\\nstay suspended. This kind of execution is referred to as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lazy evaluation\"), \" (or\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"call-by-need\"), \")\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \".\"), mdx(\"p\", null, \"Lazy evaluation is heavily used for code optimization. Instead of creating\\nmemory-demanding data structures with elements (such as lists, tuples, ranges)\\nand passing them around lazy evaluation allows us to pass data in sequences of\\nvalues from one place to another without keeping it in memory after computation\\nis completed.\"), mdx(\"h3\", null, \"Generator Objects\"), mdx(\"p\", null, \"It turns out that implementing the iterator protocol in a class is a lot of\\nwork. This is where \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"generator objects\"), \" (or generators for short) come in!\\nInstead of creating iterators with a class we'll see that it is much easier to\\ncreate iterators using a special function that has the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement in\\nfunction body. These special functions are called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"generator functions\"), \" and are\\nable to create iterator objects called generator.\"), mdx(\"h4\", null, \"Generator Function vs. Generators\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement, just like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement, is bound to the body\\nof a function and cannot be used outside of it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers {3}\",\n    \"noLineNumbers\": true,\n    \"{3}\": true\n  }), \">>> yield 42\\n  File \\\"<stdin>\\\", line 1\\nSyntaxError: 'yield' outside function\\n\")), mdx(\"p\", null, \"Functions that have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements inside the function body are called\\ngenerator functions. These are different from regular functions without the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement because they create generator objects. You can think of\\ngenerator functions as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"generator factories\"), \" that instantiate generators.\"), mdx(\"p\", null, \"Let's write a regular function and a generator function and call them to see\\nthe difference:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers {5,10}\",\n    \"noLineNumbers\": true,\n    \"{5,10}\": true\n  }), \">>> def f():\\n...     return 42\\n...\\n>>> f()\\n42\\n>>> def generator_factory():\\n...     yield 42\\n...\\n>>> generator_factory()\\n<generator object generator_factory at 0x7f49eb1f8f90>\\n\")), mdx(\"p\", null, \"The regular function returns the value which follows the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement in\\nthe function definition while calling the generator function creates a\\ngenerator object (see the highlighted lines in the code block).\"), mdx(\"p\", null, \"Like iterators, generators implement the iterator protocol. We'll create a\\ngenerator by calling the generator function and show that generators pass all\\nthe tests like iterators:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> g = generator_factory() # create a generator\\n>>> hasattr(g, \\\"__iter__\\\")\\nTrue\\n>>> g is iter(g)\\nTrue\\n>>> hasattr(g, \\\"__next__\\\")\\nTrue\\n>>> next(g)\\n42\\n>>> next(g)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"These are similar to the tests used to show that iterators support the iterator\\nprotocol.\"), mdx(\"p\", null, \"A generator instance with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__next__\"), \" methods is created after\\ncalling a generator function. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" function called on a generator returns\\nthe same generator instance. Additionally, calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function\\nactivates generators and executes the body of the generator function until the\\nnext \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement is reached and produces the value which follows the\\nstatement. Once it produces a value generator suspends and waits for the next\\nactivation with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. When there are no more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements\\nin the function body generator gets exhausted and raises the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteratation\"), \"\\nexception.\"), mdx(\"h4\", null, \"Revisiting the Previous Iterators\"), mdx(\"p\", null, \"The previous section shows that generator functions provide a powerful\\nframeworks for creating iterator objects called generators. Therefore, we'll\\nrewrite the previous examples: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iterator_t\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Echo\"), \" using\\ngenerator functions.\"), mdx(\"h5\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"iterator_t\"), \" instance:\"), mdx(\"p\", null, \"Let's write a generator function which creates generators that are similar to\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iterator_t\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def gen_iterator_t():\\n   yield 0\\n   yield 1\\n   yield 2\\n   return None\\n\")), mdx(\"p\", null, \"Generator functions are usually written without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return None\"), \" statement\\nbecause in Python any function that doesn't have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement by\\ndefault returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \". Python versions > 3.3 support the use of both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements inside the body of a generator function.\"), mdx(\"p\", null, \"Let's call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_iterator_t\"), \" to create a generator instance and, since\\ngenerators implement the iterator protocol, use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function to change\\nthe generator state and produce values:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> iterator_t = gen_iterator_t()\\n>>> next(iterator_t)\\n0\\n>>> next(iterator_t)\\n1\\n>>> next(iterator_t)\\n2\\n>>> next(iterator_t)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function activates the generator and advances the code inside the\\ngenerator function until the next \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement. When a yield statement is\\nreached the generator produces a value and suspends. It reactivates when it\\ngets called with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. When there are no more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements\\nor when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement inside the generator function is reached the\\ngenerator raises the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception at which point it behaves like\\nan exhausted iterator.\"), mdx(\"h5\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"Countdown\"), \" class:\"), mdx(\"p\", null, \"The following generator function is able to substitute the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def gen_countdown(start):\\n    count = start\\n    while count > 0:\\n        yield count\\n        count -= 1\\n    return None\\n\")), mdx(\"p\", null, \"Generator functions, like regular functions, accept function arguments. Our\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_countdown\"), \" is simpler to read and easier to maintain compared to the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class which does the same job. Notice also that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \"\\nstatement is used inside a loop, this is a very common pattern for writing\\ngenerator functions.\"), mdx(\"p\", null, \"Let's show that generators created with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_countdown\"), \" behaves like iterators\\ninstantiated with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Countdown\"), \" class:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> new_year = gen_countdown(3)\\n>>> new_year is iter(new_year)\\nTrue\\n>>> next(new_year)\\n3\\n>>> next(new_year)\\n2\\n>>> next(new_year)\\n1\\n>>> next(new_year)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"Generator instance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_year\"), \" behaves exactly like the iterator instance\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_year\"), \". Therefore, in Python generators and iterators are most often\\nconsidered synonyms.\"), mdx(\"h5\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"Echo\"), \" class:\"), mdx(\"p\", null, \"Using infinite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" loops it's possible to write generator functions that\\ncontain infinite number of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements. This pattern supports\\nconstruction of infinite generators.\"), mdx(\"p\", null, \"The following generator function creates generators similar to the iterators\\ncreated with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Echo\"), \" class:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def gen_echo(message):\\n    while True:\\n        yield message\\n\")), mdx(\"p\", null, \"Notice that we've also intentionally left out the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return None\"), \". This is\\nprobably for the better because this generator function cannot execute until\\nthe function end. Thus, it's not able to return anything.\"), mdx(\"p\", null, \"Let's create an infinite generator:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> troll_kid = gen_echo(\\\"Why?\\\")\\n>>> next(troll_kid)\\n'Why?'\\n>>> next(troll_kid)\\n'Why?'\\n>>> next(troll_kid)\\n'Why?'\\n\")), mdx(\"p\", null, \"This generator cannot get exhausted because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement is stuck\\ninside the infinite loop. Next, we'll talk about retrieving return values from\\ngenerators once they're exhausted.\"), mdx(\"h4\", null, \"Retrieving Return Values from Generators\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.python.org/dev/peps/pep-0380/\"\n  }), \"PEP 380\"), \" was implemented in Python\\n3.3 and ever since then generators are able to return a value once they're\\nexhausted.  The return value of a generator is passed inside the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception in an attribute called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \".\"), mdx(\"p\", null, \"Take a look at the following generator function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from collections import namedtuple\\n\\nStat = namedtuple(\\\"Stat\\\", [\\\"total\\\", \\\"positive\\\", \\\"negative\\\"])\\n\\ndef filter_from(words, f):\\n    c = 0\\n    for total, w in enumerate(words, start=1):\\n        if f(w):\\n            c += 1\\n            yield w\\n    return Stat(total, c, total-c)\\n\")), mdx(\"p\", null, \"This generator function filters out elements from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"words\"), \" according to the rule\\nin the second argument. The second argument is a function which takes a string\\nand returns a boolean. While generator is active it counts the number of total\\nelements and the ones that have passed through the filter. Once generator is\\nexhausted it returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Stat\"), \" namedtuple with statistics about the total and the\\nfiltered number of items.\"), mdx(\"p\", null, \"Let's create a generator that searches for palindromes (symmetric words):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> p = filter_from(\\n...     words := \\\"Boeing 737 landed at noon in Cairo.\\\".split(),\\n...     lambda x: x == x[::-1]\\n... )\\n\")), mdx(\"p\", null, \"The first argument is list of words from the sentence and the second argument\\nis lambda function that checks if a word is palindrome. Additionally, using the\\nwalrus operator (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":=\"), \") we've assigned the list of words from the sentence to\\nvariable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"words\"), \" so that it's easy to recreate the same generator once it's\\nexhausted.\"), mdx(\"p\", null, \"Let's filter out palindromes with our generator and iterate over them with the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function until the generator gets exhausted:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers {6,7,8}\",\n    \"noLineNumbers\": true,\n    \"{6,7,8}\": true\n  }), \">>> next(p)\\n'737'\\n>>> next(p)\\n'noon'\\n>>> next(p)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration: Stat(total=7, positive=2, negative=5)\\n\")), mdx(\"p\", null, \"Notice that when the generator gets exhausted the traceback message indicates\\nthat the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception object carries the return value from the\\ngenerator. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" object must be caught with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"except\"), \"\\nstatements before the return value of the generator is retrieved from the\\nattribute called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \".\"), mdx(\"p\", null, \"Here's an example of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" loop that captures the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \"\\nexception, retrieves the return value of the generator and breaks out of the\\nloop:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> p = filter_from(words, lambda x: x == x[::-1])\\n>>> while True:\\n...     try:\\n...         v = next(p)\\n...     except StopIteration as exception:\\n...         print(return_value := exception.value)\\n...         break\\n...     else:\\n...         print(v)\\n...\\n737\\nnoon\\nStat(total=7, positive=2, negative=5)\\n\")), mdx(\"p\", null, \"Returning values from generator functions is more practical when working in the\\ncontext of coroutines. Although sometimes returning a value from a generator is\\nuseful because it allows programmer to reflect on generated elements to make\\nfurther decisions.\"), mdx(\"h4\", null, \"Generator Expressions: The Anonymous Generators\"), mdx(\"p\", null, \"Generator expressions further shorten the process of creating generators by\\ndelegating anonymous generators directly and without the need for calling\\ngenerator functions. The syntax for generator expressions is similar to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/tutorial/datastructures.html?highlight=list%20comprehension#list-comprehensions\"\n  }), \"list\\ncomprehensions\"), \"\\nwith a difference that generator expresses are created inside parenthesis \\\"()\\\"\\nwhile list comprehensions are created inside square brackets \\\"[]\\\".\"), mdx(\"p\", null, \"Let's create a generator instance similar to the one we've created using\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_countdown\"), \" and show that the created generator supports the iterator\\nprotocol:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> new_year = (i for i in reversed(range(1, 4)))\\n>>> new_year is iter(new_year)\\nTrue\\n>>> next(new_year)\\n3\\n>>> next(new_year)\\n2\\n>>> next(new_year)\\n1\\n>>> next(new_year)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"With this generator expression we've iterated over every element of\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reversed(range(1, 4))\"), \" and yielded it. Just like any other iterator object\\ngenerator expressions can be used inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> for count in (i for i in reversed(range(1, 4))):\\n...     print(count)\\n...\\n3\\n2\\n1\\n\")), mdx(\"p\", null, \"Notice that generator expressions are anonymous just like lambda functions.\\nAlthough many Pythonistas are dreaded by lambda functions they seem to be happy\\nusing generator expressions, but when there is a need to reuse a generator in\\ndifferent places it's almost always better to write a separate generator\\nfunction.\"), mdx(\"p\", null, \"Flexibility of generator expressions makes it easy to combine them with\\nfunction arguments. Similar to list comprehensions, we can crate lists by\\ncombining generator expressions and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" function, see here:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> list(i for i in reversed(range(1, 4)))\\n[3, 2, 1]\\n\")), mdx(\"p\", null, \"Additionally, generator expressions support the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" statement which allows\\nthem to behave like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" built-in function. Let's filter out even\\narguments from the previous example and create a list with only odd numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> list(i for i in reversed(range(1, 4)) if i % 2 != 0)\\n[3, 1]\\n\")), mdx(\"p\", null, \"For exercise, rewrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"troll_kid\"), \" generator using a generator expression (hint:\\nuse\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/itertools.html#itertools.count\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"itertools.count\")), \"\\nor \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/itertools.html#itertools.repeat\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"itertools.repeat\")), \")\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-2\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }), \"2\")), \".\"), mdx(\"p\", null, \"More information and better examples of generator expressions are found in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.python.org/dev/peps/pep-0289/\"\n  }), \"PEP\\n289\"), \" which was written by the\\never-amusing Python core developer Raymond Hettinger (check out his amazing\\nYouTube videos).\"), mdx(\"h3\", null, \"Primer of Generator Usage in OOP\"), mdx(\"p\", null, \"It was previously mentioned that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method must always return an\\niterator. Because generator functions return generators (which are identical to\\niterators) they are suitable for implementing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method. This is the\\npreferred way of creating user-defined class for iterable objects.\"), mdx(\"h4\", null, \"Generator Functions\"), mdx(\"p\", null, \"Let's create a container class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PicnicBasket\"), \" which has an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method.\\nThis means that instances of this class are going to be iterable objects:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"class PicnicBasket:\\n    def __init__(self, *content):\\n        self._content = content\\n\\n    def __iter__(self):\\n        for item in self._content:\\n            yield item\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method is implemented as a generator function. Notice that the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method doesn't contain the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement because it's expected\\nthat it returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" once its generator is exhausted.\"), mdx(\"h4\", null, \"Generator Expression\"), mdx(\"p\", null, \"Using generator expressions it's possible to rewrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PicnicBasket.__iter__\"), \"\\nmethod:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"class PicnicBasket:\\n    def __init__(self, *content):\\n        self._content = content\\n\\n    def __iter__(self):\\n        return (item for item in self._content)\\n\")), mdx(\"p\", null, \"This example clearly shows that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method returns a generator.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PicnicBasket\"), \" instances are iterable because they have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" method which\\nreturns an iterator. We'll create an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PicnicBasket\"), \" and than put in\\na few items for an afternoon picnic:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> wood_basket = PicnicBasket(\\\"blanket\\\", \\\"lemonade\\\" ,\\\"sandwiches\\\",)\\n>>> for item in wood_basket:\\n...     print(item)\\n...\\nblanket\\nlemonade\\nsandwiches\\n\")), mdx(\"p\", null, \"Now our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wood_basket\"), \" is an iterable object (iterable but not iterator) and\\ntherefore it can be used inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"In this article we've distinguished between itearbles, objects with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \"\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \" dunder methods, and iterators which are objects that implement\\nthe iterator protocol. In the context of object-oriented programming we've\\nimplemented classes that create iterators and talked about the concept of lazy\\nevaluation.\"), mdx(\"p\", null, \"Generator functions provide a simple framework for creating iterators called\\ngenerators. Instead of implementing iterator protocol inside a class it's\\neasier and more readable to control the state of a generator with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \"\\nstatement. Additionally, we're able to create anonymous generators using\\ngenerator expressions.\"), mdx(\"p\", null, \"The last OOP example is only one of many where generators are handy. Now when\\nyou have the right tools and knowledge about iterables, iterators, and\\ngenerators try to discover others!\"), mdx(\"p\", null, \"If your looking for other examples where iterators are used in Python I'd\\nsuggest reading \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mylette.rs/revisiting-the-mechanism-behind-the-for-statement\"\n  }), \"Revisiting the Mechanism Behind the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"for\"), \" Statement\"), \". That article explains how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" statement relies on\\nthe iterator protocol for iterating over iterable objects.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"Lazy evaluation in Python is limited to iterators and is very different\\nfrom the lazy evaluation used in Haskell. Lazy evaluation in Haskell is\\na-whole-nother-level of lazy and amazing!\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")), mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-2\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gen1 = (\\\"Why?\\\" for _ in itertools.count())\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gen2 = (i for i in\\nitertools.repeat(\\\"Why?\\\"))\"), \".\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"This article explains the grounding structure of iteration in Python. The\narticle start by looking at the iterator protocol and implementsâ€¦","timeToRead":11,"banner":null}},"pageContext":{"slug":"/going-over-iterators-and-generators","formatString":"DD.MM.YYYY"}}}