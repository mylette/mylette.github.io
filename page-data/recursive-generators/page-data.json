{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/recursive-generators","result":{"data":{"post":{"__typename":"MdxPost","slug":"/recursive-generators","title":"Recursive Generators","date":"26.08.2020","tags":[{"name":"python","slug":"python"},{"name":"iterators","slug":"iterators"},{"name":"functional programming","slug":"functional-programming"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Recursive Generators\",\n  \"date\": \"2020-08-26T00:00:00.000Z\",\n  \"tags\": [\"python\", \"iterators\", \"functional programming\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This article provides alternative ways to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cycle\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"repeat\"), \" generator functions that are a part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itertools\"), \" module in the\\nPython Standard Library (PSL). The proposed solutions are based on the\\nprinciple of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"functional recursion\"), \" and are similar to design patterns used in\\nfunctional programming. The main message of the article is, however, not to\\npropose potential improvements to the PSL but to challenge programmers and open\\nthem to a new way of thinking about iterators. It also goes to show that in the\\ncontext of iterators the idea of functional recursion comes naturally with the\\nuse of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement. Hence, it's very unfortunate that Python\\ndoesn't have better support for recursion.\"), mdx(\"h3\", null, \"Recursive Generators 101\"), mdx(\"p\", null, \"Generator functions are specific functions that contain \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \"\\nstatements inside their function body. Unlike regular functions, generator\\nfunctions return generator objects when they are called. If you feel that you\\nwould like to brush up your knowledge about generators take a look at my other\\narticle called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mylette.rs/going-over-iterators-and-generators\"\n  }), \"Going Over Iterators and\\nGenerators\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Recursive generator functions\"), \" are a subset of regular generator functions.\\nMore specifically, recursive generator function is defined by calling itself\\ninside the body of the same generator function. The main problem for achieving\\nrecursion with generator functions is the fact that they return a generator\\ninstance which awaits for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" built-in function to call it in order to\\nproduce a value. This behaviour obviously hinders recursion.  Therefore,\\ncalling a generator function returns a generator that needs to be unpacked in\\norder to establish recursion. We'll see that in Python this can be achieved\\nusing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement.\"), mdx(\"p\", null, \"The following subsection introduces the concept of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement\\nwhich is essential for unpacking iterators (generators). Afterwards, we'll use\\nit to establish recursive iteration in recursive generator functions.\"), mdx(\"h5\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"yield from\"), \" Statement: The Unpacking Mechanism\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement was introduced to delegate subgenerators in the\\ncontext of coroutines (see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.python.org/dev/peps/pep-0380/\"\n  }), \"PEP\\n380\"), \"). However, when it's used in\\nthe context of simple generators (non-coroutine objects) its usage becomes\\nsimple. Therefore, for the purpose of this article consider the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \"\\nstatement as a way to unpack iterable objects (objects with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__iter__\"), \" or\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__getitem__\"), \" dunder methods) until they raise the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception at\\nwhich point the unpacking stops. Consider the following generator function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def unpack(iterable):\\n    yield from iterable\\n\")), mdx(\"p\", null, \"As long as we make sure not to pass a coroutine as function argument, the above\\ngenerator function behaves the same as the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def unpack_(iterable):\\n    for i in iterable:\\n        yield i\\n\")), mdx(\"p\", null, \"Both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unpack\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unpack_\"), \" are generator functions that accept a single\\nargument and return a generator. To show that the functions produce the same\\nresults the following example unpacks a tuple and save it in a list:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> c = (1, 2, 3,)\\n>>> list(unpack(c))\\n[1, 2, 3]\\n>>> list(unpack_(c))\\n[1, 2, 3]\\n\")), mdx(\"p\", null, \"Now let's create an iterator and pass it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> i = iter(c)\\n>>> list(unpack(i))\\n[1, 2, 3]\\n\")), mdx(\"p\", null, \"This shows that the behaviour of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield_from\"), \" statement is the same for\\ncontainers (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"range\"), \") and iterable objects. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \"\\nstatement provides a simple framework for unpacking iterable objects until the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception signals to stop unpacking. \"), mdx(\"h5\", null, \"Recursive Generators: The Matriyoshka Example\"), mdx(\"p\", null, \"In the following example we'll look at the recursive nature of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Matryoshka_doll\"\n  }), \"Matriyoshka\\ndoll\"), \" and create a recursive\\ngenerator function that unpacks the doll.\"), mdx(\"p\", null, \"We'll use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NamedTuple\"), \" type to model the doll and specify the size of the doll\\nin the field called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \". This field reflects the number of dolls that the\\noriginal holds inside of it. The smallest doll has has the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \" field equal\\nto zero (i.e., it doesn't contain other dolls). Here's the model for a\\nmatriyoshka doll:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from typing import NamedTuple\\n\\n\\nclass Matriyoshka(NamedTuple):\\n    size: int\\n\")), mdx(\"p\", null, \"For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Matriyoshka(size=2)\"), \" is an object that models a doll that has two\\ndolls inside it, namely \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Matriyoshka(size=1)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Matriyoshka(size=0)\"), \"\\nobjects. Note that with the relationship between the objects is weak in the\\nsense that the original doll only has a larger size but doesn't explicitly\\nenclose the smaller dolls.\"), mdx(\"p\", null, \"Let's create a recursive generator function which recursively opens each doll\\nuntil the smallest doll is reached (i.e., doll that has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \" equal to zero):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from typing import Iterator\\n\\n\\ndef open_matriyoshka(m: Matriyoshka) -> Iterator[Matriyoshka]:\\n    yield m\\n    if m.size > 0:\\n        yield from open_matriyoshka(m._make([m.size - 1]))\\n\")), mdx(\"p\", null, \"This function is a recursive generator function because it calls itself inside\\nof the function body. When the generator function is called with one argument\\nit returns a generator object. Generator objects are iterable and therefore\\ninteract nicely with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement\\nunpacks the generator which is created by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"open_matriyoshka\"), \" with a\\ndoll of decremented size as a function argument. The decrementing ensures that\\nthe doll size becomes smaller. The recursive iteration continues until the\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"base case for recursion\"), \" is reached (i.e., until the algorithm decrements the\\ndoll size sufficiently many times to reach the smallest doll with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \"\\nfield equal to zero). Once the base case is reached the recursion stops.\"), mdx(\"p\", null, \"Let's test our recursive generator function and show that it can be used to\\nunpack \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Matriyoshka\"), \" objects:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> next(g := open_matriyoshka(Matriyoshka(size=2)))\\nMatriyoshka(size=2)\\n>>> next(g)\\nMatriyoshka(size=1)\\n>>> next(g)\\nMatriyoshka(size=0)\\n>>> next(g)\\nTraceback (most recent call last):\\n  File \\\"<stdin>\\\", line 1, in <module>\\nStopIteration\\n\")), mdx(\"p\", null, \"Generator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" is created after calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"open_matriyoshka\"), \" with an argument\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Matriyoshka(size=2)\"), \", i.e., object that represents a doll which has two dolls\\ninside it. Each time the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" built-in function is called on the generator\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" the code inside the generator function runs until the next \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \"\\nstatement and produces a value which follows it. When the code reaches the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement it creates a new generator and continues searching for\\nthe next \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement inside it. When there are no more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements\\nthe original generator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" is exhausted and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception is\\nraised.\"), mdx(\"p\", null, \"In the following section we'll use the recursive mechanism to rewrite three\\nfunctions from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itertools\"), \" module.\"), mdx(\"h3\", null, \"Reimplementing \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"count\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"cycle\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"repeat\"), \" Functions\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cycle\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"repeat\"), \" are iterator factories defined in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itertools\"), \"\\nmodule that are used for creating well-optimized iterators that are both fast\\nand memory efficient. The functions are implemented in C programming language\\nand live inside the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/python/cpython/blob/384621c42f9102e31ba2c47feba144af09c989e5/Modules/itertoolsmodule.c\"\n  }), \"itertoolsmodule.c\"), \"\\nfile. For the sake of completeness every function from the module has an\\nequivalent Python implementation which complements the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/itertools.html#itertools.cycle\"\n  }), \"documentation\"), \"\\nof the module. Before reimplementing these functions we'll cover the basic use\\ncases and the way they are implemented according to the Python documentation:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"count\"), \" creates an infinite counter \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">>> count(10) --> 10 11 12\\n13 14 ...\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"{3-5}\",\n    \"{3-5}\": true\n  }), \"def count(start=0, step=1):\\n    n = start\\n    while True:\\n        yield n\\n        n += step\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cycle\"), \" indefinitely cycles over an iterable object \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">>> cycle(\\\"ABC\\\") --> A B C A B C A ...\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"{6-8}\",\n    \"{6-8}\": true\n  }), \"def cycle(iterable):\\n    saved = []\\n    for element in iterable:\\n        yield element\\n        saved.append(element)\\n    while saved:\\n        for element in saved:\\n            yield element\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"repeat\"), \" repeats an object infinitely or finite number of times \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">>>\\nrepeat(10, 3) --> 10 10 10\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"{3,4}\",\n    \"{3,4}\": true\n  }), \"def repeat(object, times=None):\\n    if times is None:\\n        while True:\\n            yield object\\n    else:\\n        for i in range(times):\\n            yield object\\n\")), mdx(\"p\", null, \"Note that these functions share the same design pattern. They instantiate\\ninfinite iterators by dropping into an infinite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" loop (highlighted lines\\nin the above code examples). This ensures that the iterators always have a\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statement that produces a new value and that the iterator is unable to\\nraise the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopIteration\"), \" exception (i.e., to get exhausted). This particular\\ndesign, using an infinite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \" loop, is an obvious solution that a lot of\\nprogrammers in the context of imperative programming are comfortable with.\"), mdx(\"p\", null, \"Next we'll put on our \\\"functional-programming\\\" hats and reimplement these\\nfunctions in the form of previously introduced recursive generator functions.\"), mdx(\"h5\", null, \"Recursive \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"count\"), \" Function\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" function is probably the simplest one to implement:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from typing import Union\\n\\nNumber = Union[int, float]\\n\\n\\ndef recount(x: Number, step: Number = 1) -> Number:\\n    yield x\\n    yield from recount(x + step, step)\\n\")), mdx(\"p\", null, \"When this generator function is called it creates a generator object. The\\ngenerator simply yields the first argument that is passed when the generator\\nfunction is called. Then it creates a new generator with an incremented value.\\nThe new generator is unpacked using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement. The code\\ncontinues to search through the newly created generator for the next \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \"\\nstatement. That way new values are being produced. Each time a new value is\\nproduces a new generators with an incremented value is created. Here's an\\nexample:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> r = recount(10, 2)\\n>>> next(r)\\n10\\n>>> next(r)\\n12\\n>>> next(r)\\n14\\n>>> next(r)\\n16\\n\")), mdx(\"p\", null, \"We'll use the same idea to reimplement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cycle\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"repeat\"), \" functions.\\nFirst the generator needs to yield a value and than it recursively creates a\\nnew generator which gets unpacked.\"), mdx(\"h5\", null, \"Recursive \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"cycle\"), \" Function\"), mdx(\"p\", null, \"Looking at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cycle\"), \" function you'll notice that there is a quirk. Before\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cycle\"), \" drops into the infinite loop it saves elements from the iterable into a\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" type object. This ensures that the iterable over which the code cycles\\ndoesn't get exhausted. This is not needed for container-type objects (e.g.,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"range\"), \") but is important for iterators and generators since\\nthey get exhausted once there are no more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" statements to produce new\\nvalues. To create recursive generator function we'll use a similar trick and\\nmake a copy of the iterator. The idea is to exhaust one iterator copy and use\\nthe other as input for the recursive generator function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from itertools import tee\\nfrom typing import Iterable\\n\\n\\ndef recycle(iterable: Iterable) -> Iterable:\\n    i, i_copy = tee(iterable)\\n    yield from i_copy\\n    yield from recycle(i)\\n\")), mdx(\"p\", null, \"If the function didn't create a copy it would have only worked for\\ncontainer-type objects. This implementation, however, is able to infinitely\\ncycle over any iterable object. We can test this by combining two recursive\\ngenerator functions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> g = recycle(open_matriyoshka(Matriyoshka(size=2)))\\n>>> next(g)\\nMatriyoshka(size=2)\\n>>> next(g)\\nMatriyoshka(size=1)\\n>>> next(g)\\nMatriyoshka(size=0)\\n>>> next(g)\\nMatriyoshka(size=2)\\n\")), mdx(\"p\", null, \"On the downside this recursive generator function comes with a performance\\noverhead because it makes a copy of the iterable each time it enters a new\\ncycle.\"), mdx(\"h5\", null, \"Recursive \", mdx(\"inlineCode\", {\n    parentName: \"h5\"\n  }, \"repeat\"), \" Function\"), mdx(\"p\", null, \"Examples of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recount\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recycle\"), \" have shown how to create infinite recursive\\ngenerators. Reimplementation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"repeat\"), \" poses a new problem. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"repeat\"), \"\\ncan create finite iterators the recursive generator function requires a base\\ncase to stop the recursion. Take a look at the following implementation:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"from typing import Iterator, TypeVar\\n\\nT = TypeVar('T')\\n\\n\\ndef rerepeat(x: T, times: int = 0) -> Iterator[T]:\\n    yield x\\n    if (new_times := times - 1) != 0:\\n        yield from rerepeat(x, new_times)\\n\")), mdx(\"p\", null, \"Generators created by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rerepeat\"), \" yield the first argument used during\\nthe function call. Afterwards the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" argument gets decremented. For the\\ngenerators with positive \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" the decrementing means that the value becomes\\ncloser to one. When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" becomes one the base case is reached. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \"\\nstatement doesn't activate and the generator stops unpacking new generators.\\nHowever, for the generators with negative \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" (or zero) the decrementing\\nleads to even smaller numbers which drive it away from the base case.\\nConsequently, the generator with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" lower or equal to zero are infinite\\ngenerators.\"), mdx(\"p\", null, \"Here's a taste of what we can do with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rerepeat\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> '-'.join(rerepeat(\\\"NANA\\\", 8)) + \\\" BATMAN!\\\"\\n'NANA-NANA-NANA-NANA-NANA-NANA-NANA-NANA BATMAN!'\\n\")), mdx(\"p\", null, \"This works only because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"times\"), \" argument is positive and the iterator is\\nfinite. However, testing the same example with an infinite iterator would blow\\nup in our face!\"), mdx(\"h3\", null, \"Discussion\"), mdx(\"p\", null, \"The concept of functional recursion is applicable in the context of iterators\\nand results in the so-called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"recursive generator functions\"), \".  We've shown that\\nfunctional recursion is a natural approach for creating both finite and\\ninfinite iterators using the simplest use case of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield from\"), \" statement.\\nIt provides the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unpacking mechanism\"), \" for iterable objects and establishes the\\nflow of recursive iteration. This circumvents the need for loops in generator\\nfunctions.\"), mdx(\"p\", null, \"We've used the concept of functional recursion to reimplemented pure functions\\nfrom the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itertools\"), \" module. These exercises have shown how to set base case\\nfor recursion. While implementing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recycle\"), \" function it was pointed out\\nthat container-type objects, unlike iterators, cannot be exhausted. Therefore,\\ncareful consideration has to be made to reflect the use case when designing a\\nrecursive generator function.\"), mdx(\"p\", null, \"It is well-known that recursion in Python is a crippled tool since it builds on\\ntop of the C stack. This is very unfortunate because it limits the application\\nof recursive generator function. Until the problem with recursion gets solved\\nrecursive generator will only be a mental exercise aimed to help programmers\\nexpand their way of thinking in terms of tools that are used in functional\\nprogramming.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"This article provides alternative ways to implement  count ,  cycle  and\n repeat  generator functions that are a part of the  itertools…","timeToRead":6,"banner":null}},"pageContext":{"slug":"/recursive-generators","formatString":"DD.MM.YYYY"}}}