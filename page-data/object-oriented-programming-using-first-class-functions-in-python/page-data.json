{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/object-oriented-programming-using-first-class-functions-in-python","result":{"data":{"post":{"__typename":"MdxPost","slug":"/object-oriented-programming-using-first-class-functions-in-python","title":"Object-oriented Programming Using First-Class Functions in Python","date":"11.05.2020","tags":[{"name":"python","slug":"python"},{"name":"functional programming","slug":"functional-programming"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Object-oriented Programming Using First-Class Functions in Python\",\n  \"date\": \"2020-05-11T00:00:00.000Z\",\n  \"tags\": [\"python\", \"functional programming\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When talking about design patterns object-oriented programming (OOP) and\\nfunctional programming (FP) are considered to be the opposites. FP is\\ncharacterised by lack of state and immutable data structures while OOP is\\nwritten using mutable data structures that represent state in programs. This\\ndoesn't mean, however, that one cannot use FP to create \\\"data holders\\\" that\\nresemble objects in OOP (as we will show).\"), mdx(\"p\", null, \"Even though Python is optimized for writing imperative programs (i.e., OOP) it\\nworks fairly well for FP. It is mainly because Python supports the concept of\\nfirst-class functions. This allows Pythonistas and Pythoneers to treat\\nfunctions (with love and gratitude that they deserve) as if they are any other\\nobject in Python. This post shows how to write functional Python using\\nfirst-class functions to bridge the gap between the FP and OOP. To have a\\nbetter understanding first we need to take a look at first-class functions and\\nlexical closure.\"), mdx(\"h3\", null, \"Functions in Python are First-class Citizens\"), mdx(\"p\", null, \"Support of first-class functions means that functions in Python behave like any\\nother object. They can be passed as functional arguments or returned from other\\nfunctions. Here's an example of a first-class function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def first_class_function(arg):\\n    def enclosed_function():\\n        return arg\\n    return enclosed_function\\n\")), mdx(\"p\", null, \"Every time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \" gets called it defines a new\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enclosed_function\"), \" as it's return value. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \" returns\\nanother function it really is first class.\"), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"arg\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enclosed_function\"), \" live only inside the namescope of\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \". This means that the two objects can only be used inside\\nour \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \"! Since these objects coexist in the same namespace\\nit also means that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enclosed_function\"), \" knows what is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"arg\"), \" and can use it\\ninside it's own function namescope, this is called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lexical closure\"), \". Lexical\\nclosures capture the local state of functions and represent the ABC of\\nfunctional programming.\"), mdx(\"p\", null, \"To call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enclosed_function\"), \" you have to first call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \" and\\npass in an argument. This creates a lexical closure and returns a function\\nobject called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enclosed_function\"), \". The returned function object can be directly\\ncalled with no arguments:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> first_class_function(\\\"bar\\\")()\\n'bar'\\n\")), mdx(\"p\", null, \"Otherwise, it can be assigned to a variable and called later:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> foo = first_class_function(\\\"bar\\\")\\n>>> foo()\\n'bar'\\n\")), mdx(\"p\", null, \"In the second example, note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" is a function returned from\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \". It is important to realize that the argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"bar\\\"\"), \"\\npassed in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \" now lives inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \". This means that\\nlexical closures can be used for storing objects inside functions. Object \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \"\\nbehaves like any other (non-anonymous) function in Python, although keep in\\nmind that it was created without the explicit use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"def\"), \" keyword!  Finally,\\nwe can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" without arguments and return the value it is storing inside\\nthe closure.\"), mdx(\"p\", null, \"Lexical closures are a powerful concept in FP that is commonly used in Python\\nfor writing function decorators. For a more detailed introduction to\\nfirst-class functions head to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://dbader.org/blog/python-first-class-functions\"\n  }), \"Dan's\\npost\"), \" where this topic is\\naddressed in a structured pedagogic way.\"), mdx(\"h3\", null, \"Using First-class Functions for Storing States\"), mdx(\"p\", null, \"Let's see how class instances store state inside objects. We will build a class\\ncalled \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RoseFlower\"), \" which keeps the information about the height of a rose\\nflower in centimeters. This class has two instance methods: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"measure\"), \" which\\nallows us to measure height of a flower and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" which allows us to water\\nour beautiful rose flowers. However, there is a limit to how tall a rose flower\\ncan grow. After reaching a limit it stops growing. Here is the code\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"class RoseFlower:\\n    def __init__(self, height):\\n        self.height = height\\n\\n    def measure(self):\\n        return self.height\\n\\n    def water(self, water_cups):\\n        if (height := self.height + water_cups*0.25) <= (max_height := 50.0):\\n            self.height = height\\n        else:\\n            self.height = max_height\\n\")), mdx(\"p\", null, \"Now, we can create a single rose flower instance and store flower's height\\ninside it. We can also measure the flower's height using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"measure\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> red_rose = RoseFlower(12.5)\\n>>> red_rose.measure()\\n12.5\\n\")), mdx(\"p\", null, \"Otherwise, we can give it one cup of water so that it grows: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> red_rose.water(1)\\n>>> red_rose.measure()\\n12.75\\n\")), mdx(\"p\", null, \"Every time we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" method our instance mutates and it's height\\nattribute changes. If we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" method several times the value of the\\nheight attribute increases but the instance keeps the same reference in memory.\\nLet's take a look at the following example\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-2\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }), \"2\")), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> white_rose = RoseFlower(16.1)\\n>>> id(white_rose)\\n140559360210736\\n>>> white_rose.water(1)\\n>>> id(white_rose)\\n140559360210736\\n\")), mdx(\"p\", null, \"Although this is a simple example of OOP it sums up the process of storing\\nstate inside an object and mutating it.\"), mdx(\"p\", null, \"Using first-class functions and lexical closures we can replicate the behaviour\\nof \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RoseFlower\"), \" class. Let's take a look at how we can apply FP concepts for\\nthe same problem. We will decorate our garden by building a new flower type\\ncalled \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TulipFlower\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def TulipFlower(height):\\n    def constructor():\\n        return height\\n    return constructor\\n\")), mdx(\"p\", null, \"Notice that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TulipFlower\"), \" has the same code as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first_class_function\"), \" that\\nwe've used previously. To create an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TulipFlower\"), \" we can use the\\nfollowing:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> orange_tulip = TulipFlower(21.05)\\n>>> pink_tulip = TulipFlower(10.25)\\n\")), mdx(\"p\", null, \"Because of the lexical closure function objects \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pink_tulip\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"orange_tulip\"), \"\\nstore the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \" argument that was passed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TulipFlower\"), \". Namely, we use\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"constructor\"), \" to \\\"memorize\\\" the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height\"), \".\"), mdx(\"p\", null, \"We would also like to access the value stored inside our new instance. Instead\\nof being lazy and calling tulip objects without arguments to return their\\nheight let's build a simple function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"measure\"), \" that does that:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"def measure(tulip):\\n     return tulip()\\n\\n>>> measure(orange_tulip)\\n21.05\\n>>> measure(pink_tulip)\\n10.25\\n\")), mdx(\"p\", null, \"At this point we can create other functions that will work with tulip objects.\\nLet's make a function which allows us to interact with our beautiful tulips. We\\nwill water them and they will grow, but since they are tulips we know that they\\ncannot grow above a certain height. Here is the code\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \": \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"def water(tulip, water_cups):\\n    if (height := measure(tulip) + water_cups*0.25) <= (max_height := 50.0):\\n        return TulipFlower(height)\\n    else:\\n        return TulipFlower(max_height)\\n\")), mdx(\"p\", null, \"Now, let's use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" function to water our lovely \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pink_tulip\"), \" with one cup\\nof water at a time:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> pink_tulip_after_1cup = water(pink_tulip, 1)\\n>>> pink_tulip_after_2cup = water(pink_tulip_after_1cup, 1)\\n>>> pink_tulip_after_3cup = water(pink_tulip_after_2cup, 1)\\n>>> pink_tulip_after_4cup = water(pink_tulip_after_3cup, 1)\\n>>> measure(pink_tulip_after_4cup)\\n11.25\\n\")), mdx(\"p\", null, \"Here you see prototype-based OOP in action! Every time we apply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \"\\nfunction it returns a new instance of a tulip flower. This is referred to as\\nthe so-called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"prototype-base OOP\"), \" (a well-known concept to JavaScript\\nprogrammers). It means that every time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" is called the function takes a\\nprototype object and modifies it in order to create a new instance. We can\\ncheck this with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> id(pink_tulip)\\n140559358724704\\n>>> id(pink_tulip_after_1cup)\\n140559341576048\\n\")), mdx(\"p\", null, \"We are certain that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"water\"), \" function is returning a new object every time it is\\ncalled because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pink_tulip\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pink_tulip_after_1cup\"), \" are not the same object.\\nNotice that cloning an object and modifying it to create a new object is a\\nnatural result of using FP.\"), mdx(\"p\", null, \"You might think that calling a function several times and naming it is tedious\\nbut it is actually preferred because it protects us from having state\\nvariables. This is the reasons why it is easier to keep track of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the flow\"), \"\\nrather than \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the state\"), \" in asynchronous programs. We can rewrite the above code\\nin a compact way using Python's support for FP located inside the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3/library/functools.html\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"functools\")), \" module:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> from functools import reduce\\n>>> pink_tulip_after_4cup = reduce(water, (1,1,1,1), pink_tulip)\\n>>> measure(pink_tulip_after_4cup)\\n11.25\\n\")), mdx(\"p\", null, \"This is equivalent to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \">>> pink_tulip_after_4cup = water(water(water(water(pink_tulip, 1), 1), 1), 1)\\n>>> measure(pink_tulip_after_4cup)\\n11.25\\n\")), mdx(\"p\", null, \"As you can see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" is a valuable tool in the world of FP.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"We have introduced the concept of first-class functions and showed that Python\\nhas such support. Without lexical closures it would be impossible to do FP\\nbecause we wouldn't be able to \\\"memorize\\\" information and store it inside\\nfunctions.\"), mdx(\"p\", null, \"We have implemented a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RoseFlower\"), \" using the classical OOP\\napproach. The example was used to demonstrate how state is stored inside\\nobjects in OOP and how the objects mutate. Later, we considered the same\\nproblem by taking the FP approach. We've implemented a function called\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TulipFlower\"), \" and seen that we can use it to create objects and store\\ninformation in them. However, using the FP approach there was no object\\nmutation and our functions were pure.\"), mdx(\"p\", null, \"I hope that this excesses at least convinced you that OOP and FP are more\\nsimilar than you thought and (fingers crossed) that it your sparked interest\\nfor further exploration of the dazzling world of FP.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"Because we're using the walrus operator (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \":=\"), \") this code block is\\nsupported only in Python >= 3.8.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")), mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-2\"\n  }), \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"id\"), \" function will most likely have a different return value in your\\nPython interpreter.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"When talking about design patterns object-oriented programming (OOP) and\nfunctional programming (FP) are considered to be the opposites. FPâ€¦","timeToRead":4,"banner":null}},"pageContext":{"slug":"/object-oriented-programming-using-first-class-functions-in-python","formatString":"DD.MM.YYYY"}}}